jvm 
  read-->load-->use->assgin-->store-write
  内存分配
	优先分配到eden区（默认eden和ser的比例是8:1:1），当新生代空间不足时，直接分配到老年代中
  垃圾回收算法
	具体的回收算法，跟选择指针碰撞，还是空闲列表有关系
	标记-清除算法--空间太零散，回收之后，如果对象太大，内存空间不满足
	复制算法--开辟两个空间，永远有一半空间是空着的，资源有些浪费
	标记-整理算法--标记清楚后，对空间进行规整，增加了内存的操作，耗费时间
  类装载机制
	如何保证类的唯一性-->取决于类本身和类加载器
	双亲委派机制，保证了一个类只会由一个类加载器进行加载
	安全的单例-->定义静态内部类

mysql
  索引机制
    全值匹配我最爱，最左前缀要遵守；
	带头大哥不能死，中间兄弟不能断；
	索引列上少计算，范围之后全失效；
	LIKE百分写最右，覆盖索引不写星；
	不等空值还有or，索引失效要少用
  事务的原理
	
  sql优化的方法
	查看执行计划
  mysql 各种日志的作用形式 
	binlog二进制日志 主从复制
	redolog-->重做日志 事务持久性
	undolog-->回滚日志 
	relylog-->中断日志
	slowlog-->慢查询日志
	errorlog-->错误日志
	generallog-->一般查询日志
  InnoDB下，MVVC(基于锁的并发控制)  InnoDB在每行数据都增加两个隐藏字段，一个记录创建的版本号，一个记录删除的版本号。
  在每开启一个事务时，会生成一个事务的版本号，被操作的数据会生成一条新的数据行（临时），但是在提交前对其他事务是不可见的，对于数据的更新（包括增删改）操作成功，会将这个版本号更新到数据的行中，
  事务提交成功，将新的版本号更新到此数据行中，这样保证了每个事务操作的数据，都是互不影响的，也不存在锁的问题
  
redis
  数据结构
	socket-serverSocket 监听socket连接，通过IO多路复用，传递给队列，单线程处理队列与事件进行绑定
  缓存雪崩/缓存穿透/缓存击穿问题如何解决
	缓存雪崩--加锁，将锁的粒度细化，每次只允许指定数量的请求到达数据库层
	缓存穿透--同上
	缓存击穿--布隆过滤器
  redis锁的实现原理
    key---判断当前线程是否拿到锁，只有拿到锁的线程才能释放自己的锁
  redis高可用的方式/主从/哨兵/集群的架构
	高可用--主从+哨兵-->master，slaver，至少3台哨兵，因为存在选举的过程，选举要超过半数 pronum 和major
			哨兵时刻监控master的动态，可以主动也可以被动选举slaver成为master--主动是哨兵主动觉得master有问题，被动是通过选举觉得master有问题
			可能出现脑裂
	高并发--集群redis-cluster
  redis持久化aof/rdb的机制，优缺点
	rbd是全量持久化，适用于做冷备
	aof是增量持久化
	一般rbd是默认开启的，建议两个都开启
jdk --多线程
  多线程问题（wait/sleep/join/notify）等的各个方法的作用
	wait线程阻塞释放锁
	sleep线程阻塞不释放
	join让其他线程先执行完，自己再执行
	notify唤醒一个等待线程
	notifyAll唤醒所有等待线程
  sync于lock的相同与异同
	sync底层：monitorenter加锁，monitorexit解锁-->每个对象有一个monitor，线程加锁成功monitor+1，重入加锁monitor增加，下个线程加锁会判断monitor是否为0，不为0，阻塞等待
	相同是加锁
	lock比sync的功能性更强，调用的方法更多
  lock的分类lock是基于AQS实现的，AQS有两个重要属性，state和加锁线程
	公平锁/非公平锁/可重入锁/读写锁/乐观锁/悲观锁
  AQS
	线程1加锁，通过cas，修改state值，将当前线程赋值给加锁线程，其他线程发现state!=0,进入到等待队列，当线程1，释放锁之后，去唤醒等待队列中的第一个线程

jdk --collection
  hashMap的底层原理，数据结构
	数据结构-->数组+链表的方式(键值对是同时存放在链表上的)先是调用hashcode计算出位置，出现碰撞，在调用equals方法
	    先使用哈希算法把key计算出一个地址值，将键值对存放在数组的这个位置
		每个value中都含有一个next属性Entry<K,V>,也是key/value结构
		如果出现key计算结果相同(即哈希冲突)，将冲突的value追加在原来的value之后，相当于next节点，形成链表
		jdk1.7
		当重新调整HashMap大小的时候，确实存在条件竞争，
		因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。
		在调整大小的过程中，存储在链表中的元素的次序会反过来，
		因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，
		这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了
		允许key和value为null
		
  hashMap与currentHashMap/table的区别
	hashMap是线程不安全的
	key算法优化--->
		hash算法
			先hash，再与右移16位的值做异或，
			(注意：为什么不直接做&运算，因为hash之后的值跟数组长度的值在高16位上是没有区别的，
			他俩主要是低16位，也就是相当于高16位没有进入到计算中，很可能出现冲突的情况,
			将原来的值右移16位，也就是相当于把高16位的值和低16位的值计算在一块，这样出现重复可能性更低)
			两个值低16位相同的值	1111 1111 1111 0000 0101 1100   -->同时跟 0000 0000 0000 0000 0000 0111 1011 做 &运算， 发现两个值的高16位都是 0000 0000 0000 0000 导致两个值最后是一样的
									1111 1111 1110 0000 0101 1100
			跟右移16位的值做异或运算，是为了让这个值同时具备高低16位的特征，降低了hash冲突的可能性
		寻址算法优化
			然后再跟数组长度-1的值做&运算
			(注意：为什么不对数组长度直接进行取模得到数组下标，因为数组长度是以2的倍数进行扩展的，
			直接取模比(n-1)&速度慢)
	hashTable是使用sync关键字加锁，只能单线程使用，不允许key和value为null
	currentHashMap/hashTable是线程安全的，currentHashMap实现原理是对数据进行分段加锁
	currentHashMap
	jdk1.7数组+segment+分段锁
		第一次hash定位到segement
		第二次hash定位到数组
		分段锁是将锁放在一小段数组上，如果分配到不同的段是没有影响的，但是如果分配到同一个段里，对同一个地址操作，还是会出现问题
	jdk1.8数组+链表+红黑树
		采用的是CAS机制，当不同的线程对同一个数组操作的时候，会先进行CAS判断，该位置是否为null，如果不为null，对这个位置机型加锁，形成链表，锁的只是这一个位置
		Node：保存key，value及key的hash值的数据结构。其中value和next都用volatile修饰，保证并发的可见性
		
  常见的ArrayList LinkedList HashSet LinkedHashSet的底层数据结构
	ArrayList 是线性表(即数组)，非线程安全的数组，只存本身，方便查询，和尾部插入，增加和删除要移动数据，所有慢
	LinkedList 是链表，每个位置存放了三部分(值本身，前一个数据的地址，后一个数据的地址，增删快，查询慢
	HashSet 不允许存放重复的值
	LinkedHashSet双向链表
mq
  各个mq的优缺点
	rabbitMQ 万级，底层是erlang语言，
		高可用集群-->1.普通集群模式:queue的元数据和实例数据全部存在一个机器上，其他的机器只存queue的元数据，用户每次去访问的时候，只是通过元数据从拥有实例数据的机器上拉取数据，返回给用户
					 2.镜像集群模式:元数据和实例数据全部机器存一份，但是增加了网络开销，比较消耗性能
	rocketMQ 十万级，底层是java
	kafka 十万级，主要用于做日志/大数据量
		集群-->天生就是分布式的，每个机器上有一个leader和另一台机器上的follower，数据是分散存储在每台机器上的
			   只有当follower成功存储消息，返回成功通知，这个消息才能够被消费，当leader挂了之后，follower会成为leader继续读写，用户都是从leader上进行读写
  mq的作用
	解耦/限流/异步
  mq如何保证数据不丢，顺序
	数据丢失
		1:生产者发送给MQ，未发送成功
		2:生产者发送给MQ，MQ接收到了，但是还没发出去，挂了
		3:MQ发送给消费者，消费者还没来得及保存，挂了
	保证数据：消费者成功保存数据之后，给MQ发一个回应，MQ再给生产者发一个回应，如果失败，会进行重试
	顺序：监听同一个queue，queue是按顺序排列
  把rabbitmq的细节了解清楚一下，exchange/topic/router等，能让别人知道你确实用过
	exchange交换器
	topic主题模式
	router路由器，可以制定路由规则
  
spring
  IOC AOP
  IOC-->对象实例化，依赖注入,将对象交由Spring进行统一管理，
	1.解析xml或者收集注解，把对象封装成beandefination对象，这个对象里面封装了需要实例化类的所有信息，包括属性，方法等等
	2.对实现beanpostprofcess的类进行排序
	3.对实现beanpostfactory的类进行排序，
	4.创建单实例对象--->
	5.发布事件
  动态代理
	jdk-->是实现invokecationhandler类，实现invoke方法，invoke的调用就是需要增强的方法
	cglib-->不需要实现类，只能增强非静态方法
  

spring-cloud
  各个组件的作用
	zuul--eruka--fegin--hystrix--rabiion
	
  fegin ribbon hystrix着重了解一下，这三个组件是干啥的
  fegin远程调用
  ribbon负载均衡
  hystrix熔断/限流/降级
  hystrix作用很强大，所有的实现细节也了解一下
  hystrix两种实现方式--1.线程池
					   2.信号量
  
